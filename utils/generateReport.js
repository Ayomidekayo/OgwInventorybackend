// utils/generateReport.js
import fs from "fs-extra";
import path from "path";
import PDFDocument from "pdfkit";
import { Parser as Json2CsvParser } from "json2csv";
import dayjs from "dayjs";
import ReturnModel from "../models/Return.js";
import ReleaseLog from "../models/ReleaseLog.js";
import Item from "../models/Item.js";

const REPORTS_DIR = path.join(process.cwd(), "reports");

await fs.ensureDir(REPORTS_DIR);

/**
 * Fetch release + return records between dates and build datasets.
 */
const fetchActivity = async (startDate, endDate) => {
  const releases = await ReleaseLog.find({
    dateReleased: { $gte: startDate, $lte: endDate },
  })
    .populate("item", "name category measuringUnit")
    .populate("releasedBy", "name email")
    .lean();

  const returns = await ReturnModel.find({
    createdAt: { $gte: startDate, $lte: endDate },
  })
    .populate("item", "name category measuringUnit")
    .populate("processedBy", "name email")
    .lean();

  return { releases, returns };
};

/**
 * Create CSV file from combined activity data.
 * Returns filePath.
 */
export const generateCSV = async (filename, releases, returns) => {
  const rows = [];

  // Releases
  for (const r of releases) {
    rows.push({
      activityType: "release",
      itemName: r.item?.name || "",
      category: r.item?.category || "",
      measuringUnit: r.item?.measuringUnit || "",
      qtyReleased: r.qtyReleased ?? "",
      qtyReturned: "",
      releasedBy: r.releasedBy?.name || "",
      releasedTo: r.releasedTo || "",
      processedBy: r.releasedBy?.name || "",
      dateReleased: r.dateReleased ? new Date(r.dateReleased).toISOString() : "",
      dateReturned: "",
      condition: "",
      remarks: "",
    });
  }

  // Returns
  for (const t of returns) {
    rows.push({
      activityType: "return",
      itemName: t.item?.name || "",
      category: t.item?.category || "",
      measuringUnit: t.item?.measuringUnit || "",
      qtyReleased: "",
      qtyReturned: t.quantityReturned ?? "",
      releasedBy: "",
      releasedTo: t.returnedBy || "",
      processedBy: t.processedBy?.name || "",
      dateReleased: "",
      dateReturned: t.dateReturned ? new Date(t.dateReturned).toISOString() : (t.createdAt ? new Date(t.createdAt).toISOString() : ""),
      condition: t.condition || "",
      remarks: t.remarks || "",
    });
  }

  const parser = new Json2CsvParser({ flatten: true });
  const csv = parser.parse(rows);

  const filePath = path.join(REPORTS_DIR, filename);
  await fs.writeFile(filePath, csv, "utf8");
  return filePath;
};

/**
 * Create a PDF summary file (human-readable)
 * Returns filePath.
 */
export const generatePDF = async (filename, summary, releases, returns) => {
  const filePath = path.join(REPORTS_DIR, filename);
  const doc = new PDFDocument({ margin: 36, size: "A4" });
  const stream = fs.createWriteStream(filePath);
  doc.pipe(stream);

  // Header
  doc.fontSize(18).text(summary.title, { align: "center" });
  doc.moveDown(0.5);
  doc.fontSize(10).text(`Period: ${summary.period}`, { align: "center" });
  doc.moveDown();

  // Totals
  doc.fontSize(11).text(`Total Releases: ${summary.totalReleases}`);
  doc.text(`Total Returns: ${summary.totalReturns}`);
  doc.text(`Total Quantity Released: ${summary.totalQtyReleased}`);
  doc.text(`Total Quantity Returned: ${summary.totalQtyReturned}`);
  doc.moveDown();

  // Table: Top items (grouped by item)
  doc.fontSize(12).text("Activity by Item", { underline: true });
  doc.moveDown(0.3);

  const grouped = summary.groupedByItem;
  for (const key of Object.keys(grouped)) {
    const it = grouped[key];
    doc.fontSize(11).text(`${it.name} (${it.category}) — Released: ${it.totalReleased} — Returned: ${it.totalReturned}`);
    // list recent records (limit 5)
    const recent = it.records.slice(-5).reverse();
    for (const r of recent) {
      const type = r.activityType;
      const date = r.date ? dayjs(r.date).format("YYYY-MM-DD HH:mm") : "";
      const info = type === "release"
        ? `Released ${r.qtyReleased} to ${r.releasedTo} by ${r.releasedBy || "N/A"} on ${date}`
        : `Returned ${r.qtyReturned} by ${r.returnedBy || r.processedBy || "N/A"} on ${date} (condition: ${r.condition || "N/A"})`;
      doc.fontSize(9).text(`  • ${info}`);
    }
    doc.moveDown(0.2);
  }

  doc.moveDown(1);
  doc.fontSize(10).text("Generated by Inventory Management System", { align: "center" });
  doc.end();

  await new Promise((resolve, reject) => {
    stream.on("finish", resolve);
    stream.on("error", reject);
  });

  return filePath;
};

/**
 * Build summary structure used both for PDF and email.
 */
const buildSummary = (releases, returns, startDate, endDate) => {
  const totalReleases = releases.length;
  const totalReturns = returns.length;
  const totalQtyReleased = releases.reduce((s, r) => s + (r.qtyReleased || 0), 0);
  const totalQtyReturned = returns.reduce((s, r) => s + (r.quantityReturned || 0), 0);

  // group by item id
  const groupedByItem = {};
  const pushRecord = (itemId, record) => {
    const k = String(itemId || "unknown");
    if (!groupedByItem[k]) groupedByItem[k] = { name: record.item?.name || "Unknown", category: record.item?.category || "Uncategorized", totalReleased: 0, totalReturned: 0, records: [] };
    groupedByItem[k].records.push(record);
    if (record.activityType === "release") groupedByItem[k].totalReleased += (record.qtyReleased || 0);
    if (record.activityType === "return") groupedByItem[k].totalReturned += (record.qtyReturned || 0);
  };

  for (const r of releases) {
    pushRecord(r.item?._id, {
      activityType: "release",
      item: r.item,
      qtyReleased: r.qtyReleased,
      releasedTo: r.releasedTo,
      releasedBy: r.releasedBy?.name || r.releasedBy,
      date: r.dateReleased || r.createdAt,
    });
  }
  for (const t of returns) {
    pushRecord(t.item?._id, {
      activityType: "return",
      item: t.item,
      qtyReturned: t.quantityReturned,
      returnedBy: t.returnedBy,
      processedBy: t.processedBy?.name || "",
      date: t.dateReturned || t.createdAt,
      condition: t.condition,
    });
  }

  return {
    totalReleases,
    totalReturns,
    totalQtyReleased,
    totalQtyReturned,
    groupedByItem,
    period: { startDate, endDate },
  };
};

/**
 * Public: generate both CSV and PDF for given date range and prefix.
 *
 * @param {Date} startDate
 * @param {Date} endDate
 * @param {"weekly"|"monthly"} type
 * @returns {Object} { pdfPath, csvPath, summary }
 */
export const generateInventoryReport = async (startDate, endDate, type = "weekly") => {
  const { releases, returns } = await fetchActivity(startDate, endDate);

  const csvFilename = `inventory_${type}_${dayjs().format("YYYYMMDD_HHmmss")}.csv`;
  const pdfFilename = `inventory_${type}_${dayjs().format("YYYYMMDD_HHmmss")}.pdf`;

  const csvPath = await generateCSV(csvFilename, releases, returns);

  const summary = buildSummary(releases, returns, startDate, endDate);

  const pdfPath = await generatePDF(pdfFilename, {
    title: `${type.charAt(0).toUpperCase() + type.slice(1)} Inventory Activity Report`,
    period: `${dayjs(startDate).format("YYYY-MM-DD")} — ${dayjs(endDate).format("YYYY-MM-DD")}`,
    totalReleases: summary.totalReleases,
    totalReturns: summary.totalReturns,
    totalQtyReleased: summary.totalQtyReleased,
    totalQtyReturned: summary.totalQtyReturned,
    groupedByItem: Object.values(summary.groupedByItem),
  }, releases, returns);

  return { pdfPath, csvPath, summary };
};
